<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tcp/IP相关 三次握手和四次挥手详情]]></title>
    <url>%2F2018%2F05%2F26%2FTcp-IP%E7%9B%B8%E5%85%B3-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E6%83%85%2F</url>
    <content type="text"><![CDATA[socket 和 httpsocket 在传输层通信 采用tcp或者UDP协议。socket 遵循TCP/UDP协议原则，只要建立连接，client和Server之间可以互相通信 http 在应用层通信 采用http或者https等协议http 采用 请求-应答机制，请求时先建立连接，并且只有Client向Server发送请求的时候 server才会向Client 发送数据 Tcp和建立连接的过程####Tcp 协议的几个标志位： SYN:请求连接 ACK:确认（Acknowledgement）只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1 Seq:顺序号码 Ack：确认号码（Acknowledge number） FIN: 结束 ####第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍]]></content>
  </entry>
  <entry>
    <title><![CDATA[回顾服务器启动器相关(C#相关，多线程)]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%9B%9E%E9%A1%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E5%99%A8%E7%9B%B8%E5%85%B3-C-%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[大概回忆复习一下吧，这块涉及到多线程和界面相关的知识。一步一步来吧：按照当时的进度来记录一下 ###大概模块 读配置部分，ConfigHander的类主要就是根据Toml的配置语法，大概配置的一个文件，按照一定的格式，key = value的形式具体语法可以自行百度，当时在Githup上找了一个C++的解释器，一个C#的解释器，前期就是熟悉Toml语法，然后熟悉解释器的用法，忘了具体链接。这里有一个链接可以看看toml 主要使用步骤就是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 Toml.Document doc = new Toml.Document(); try &#123; doc = Toml.Document.Create(filePath); if (doc == null) &#123; return false; &#125; &#125; catch (Exception ex) &#123; return false; &#125;//这里主要就是 将toml配置文件里面的内容 读到tomlData中bool isReadSuccess = ReadFile(ref doc, ref tomlData);为了方便代码复用，在后期 1. 我将这个类转化成了单例模式，便于每次使用的时候，不会重新实例化。 2. 同时TomlData这个结构，我设置成未知，在下面的赋值过程中，使用C#反射的特性，达到不同结构，不同文档，我都不用修改读配置文件的这个类。 大概把怎么写的留下来，以后有机会复习反射的时候 可以用用 bool ReadFile(ref Toml.Document doc, ref object tomlData) &#123; Type dataType = tomlData.GetType(); FieldInfo[] dataInfo = dataType.GetFields(); object obj = Activator.CreateInstance(dataType); foreach (var item in dataInfo) &#123; string value = null; bool isGetValueSuc = GetValue(item, ref doc, ref value); if (!isGetValueSuc) &#123; return false; &#125; Type t = item.FieldType; if (t == typeof(string)) &#123; item.SetValue(obj, value); &#125; else if (t == typeof(int)) &#123; int valueNum = Convert.ToInt32(value); item.SetValue(obj, valueNum); &#125; else &#123; // &#125; &#125; tomlData = obj; &#125; ProcessInfo 类 主要是从开启进程A并将A输出的log信息拿出来，并Send到Winform的box 中显示出来主要分为以及模块：开启进程提取Error和Out数据进程状态的函数封装关闭进程的实现这部分当时我在做的时候，主要困难就是1.1 开启API的一些参数了解和处理，以及一些异常的处理1.2 关闭进程，提供的接口，只有Kill，但是会导致很多数据没有存储好，这种情况下，我们采用的发消息Ctrl+c的机制，去关闭它。CtrlCEvent == 0 注意这个函数的使用路劲 ,主要是AttachConsole 通过Processid连接到相应的程序，但是不能是控制台程序 这是一些通过Dll调用的函数的调用方法 举个例子：如下所示 123456789101112// Import function for sending [Ctrl+C] sign to process [DllImport(&quot;kernel32.dll&quot;)] static extern bool GenerateConsoleCtrlEvent(uint dwCtrlEvent, uint dwProcessGroupId); [DllImport(&quot;kernel32.dll&quot;)] static extern bool AttachConsole(int dwProcessId); [DllImport(&quot;kernel32.dll&quot;)] static extern bool FreeConsole(); [DllImport(&quot;kernel32.dll&quot;)] static extern bool SetConsoleCtrlHandler(IntPtr handlerRoutine, bool add); 这是发送的具体实现，当时基本方法是从OverStack上找的解决方法 ，自己稍微做了一下修改 123456789101112131415161718192021222324252627282930void SendQuitMessageToProcess()&#123; if (_process == null) return; // This does not require the console window to be visible. var bRet = AttachConsole(_process.Id); if (!bRet) return; &#123; // isCtrlCHandled indicated whether CTRL+C signal has been handled. _isCtrlCHandled = false; CallBack callback = CtrlCEventHandler; // Rigister callBackHandler to CTRLCEVENT SetConsoleCtrlHandler(Marshal.GetFunctionPointerForDelegate(callback), true); // Send CTRLCEVENT to SERVER_START and _process&apos;s console GenerateConsoleCtrlEvent(CtrlCEvent, 0); while (!_isCtrlCHandled) &#123; Thread.Sleep(10); &#125; FreeConsole(); // Re-enable Ctrl-C handling or any subsequently started programs will inherit the disabled state. SetConsoleCtrlHandler(Marshal.GetFunctionPointerForDelegate(callback), false); &#125;&#125; 1.3 后台数据向前台传送数据的时候，开始用的SendMessage，和 PostMessage等，然后在winform窗口，用消息接收机制去接收它，在进行处理。最后直接采用的C#的委托，deleget来直接异步实现。1.4 大量数据需要实时显示到winform box上面，实时做的很差 当时采取的方式： （1）用while循环将数据提取出来，用一个临时空间存储，超过Max大小以后，在向Winform传送消息。但是一样会导致数据在读缓冲区太多，实时速度太慢。 （2）采用Process的一个读数据的接口，可以按照size来读取数据，但是会出现有些数据输出比较慢的数据会被分开。 （3）采用异步的方式，将读出来的数据放在一个队列里面，有数据就执行 Enqueue，写的时候不读，读的时候不写，采用lock的方式。基本解决问题。1234567891011121314151617181920212223242526_process.OutputDataReceived += OutputDataReceived;_process.ErrorDataReceived += ErrorDataReceived;void OutputDataReceived(object sender, DataReceivedEventArgs e)&#123; if (string.IsNullOrEmpty(e.Data)) return; lock (_outQueue) &#123; _outQueue.Enqueue(e.Data); &#125;&#125;public string GetErrOutLine()&#123; if (_errQueue.Count &lt;= 0) return null; lock (_errQueue) &#123; return _errQueue.Dequeue(); &#125;&#125;// 进程开启就可以 开始读取数据做处理了public void BeginReadMessage()&#123; _process.BeginOutputReadLine(); _process.BeginErrorReadLine();&#125; ProcessLogThread 类这个就是普通的类，主要负责调用ProcessInfo类的方法，开启A进程相关，并调用取出相关数据的接口。主要功能为下面几点：3.1 开启线程 Thread.start(process) .3.2 用死循环处理从进程A处获得的Error和Output的数据3.3 分类outPut数据，例如debug和warnning等3.4 处理读取出来的数据，用buff_size和time两个条件，判断buff是否上传到winform box处，进行显示。3.5 这个线程结束的处理情况 StartStopProcessesThread 类这个主要批量控制process的 start 和 stop等操作。4.1 ThreadStart(object obj) 为了降低耦合，不直接调用相关的函数。监控process的状态，如果状态为start则startProces。这里的线程没必要一直监控，可以适当Sleep一下，降低Cpu消耗。process的状态由winform和命令行控制。例如：start，restart，singleStart，stop，singleStop等，状态，分别执行不同4.2 Strt（），Stop，修改状态，各个状态的一个修改状态4.3 细节处理问题：后续发现 的确会有问题，状态会在进程和线程中交互被更改，可能会出现，发送的状态指令没有被执行，或者同时进程A和线程B会同时对同一个状态值进行修改，无关是否是原子操作，如果加锁操作。 但是也可以理解为一个设置，避免太频繁的对process的开关进行操作。所有的都不能完全避免被其他操作的可能。 ProcessManger 类这是一个静态类，主要用来做Process数据和Winform的一个交互情况。例如:1.读配置文件部分 2.连接 ProcessData包含了配置文件里面每个进程的一些数据 例如开启的进程对象，开启进程以后log的读取等，进程状态，所有和进程相关的一些数据 public static readonly List ProcessDataList = new List(); public static StartStopProcessesThread StartStopProcessesThread = new StartStopProcessesThread(); winform 主要就是界面和ProcessManger之间的一个交互，以及和log相关的一些操作]]></content>
  </entry>
  <entry>
    <title><![CDATA[RPC的初步了解（二）]]></title>
    <url>%2F2018%2F05%2F22%2FRPC%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇已经大致说了Server端，RPC的基本信息，这里主要说Client端相关的。我这里主要以Python为例子。大概了解一下过程，怎么去使用，以及大概的原理。这里主要根据实际使用的一个游戏自动化开源框架说一下这个是怎么使用的。 123456789101112//连接到server端connectionToServer(addr,connect_default_device)--if device_platform() == &quot;Android&quot;: # always forward port for Android # unity games poco sdk listens on Android localhost:5001 current_device().adb.forward(&quot;tcp:%s&quot; % addr[1], &quot;tcp:5001&quot;, False)---- self.conn = TcpClient(addr) self.c = RpcClient(self.conn)-- 自己使用这个接口的时候，需要使用RPClient传出来的接口，例如：1234class UnityPocoJX3MEx(): def __init__(self, agent, poco): self.rpcclient = agent.c self.poco = poco 通过封装的cmd接口，将函数传到服务端，如下所示：12345def callCmd(self, cmd, *param): return self.rpcclient.call(cmd, *param)def cmd(self, cmd, *param): return self.callCmd(cmd, *param) 举个我们最上层使用的例子：Click是我们在Server端，定义的RPC的函数，strUIPath是我们定义的函数参数，cmd_result_click是函数执行以后函数的返回值。1cmd_result_click = poco.pocoEx.cmd(&apos;Click&apos;, strUIPath)]]></content>
  </entry>
  <entry>
    <title><![CDATA[RPC的初步了解（一）]]></title>
    <url>%2F2018%2F05%2F15%2FRPC%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这里应该是主要写写基本的概念和整个流程，以及服务端处理的流程。 RPC:Remote Procedure 远程调用过程使用的环境：在准备搭建自动化收集数据的平台，因为游戏的很多客户端逻辑是C#构造的，所以一些功能性操作都是基于C#的函数，但是想用AutoGo框架来写自动化的测试用例，这时候需要跨服务使用其他语言的接口，这种情况下，接触到了RPC. 基本概念知识：1.RPC 是基于Tcp/Ip底层协议，C/S模式的一种模式。2.目的： 1.实现不同语言之间的通信，例如我这次的使用原因。 2.调用其他端，不是本机的方法。 3.使用简单，可以用简单的网络传输调用，我这里主要会研究一下，Socket的调用。 使用方法RPC 服务端通过一个通信方式 ，【导出】远程接口方法，客户端用 import 【导入】远程接口。 client 调用一些‘本地’方法。 client stub 接收到调用方法以后，将方法和参数等按照约定好的规则编码成可以在传输层传输的消息。 client stub 将编码好的规则发送到服务器 服务端监听到消息以后，开始对接收到的消息进行解码。 根据解码以后的消息规则，找到对应的函数去执行 将执行的结果进行编码，在返回给出了client.盗用一张图来说明大概过程： 这里首先主要理清楚服务端做的操作：整个操作，比较简单的操作其实就是： 服务端开启网络监听端口， 主要监听是否有连接或者数据发过来123456789// 监听 事件Socket.Listen(ip, port, OnAccept)// 自定义事件OnAccept()&#123; //自定义两个事件 so.OnError = OnError; so.OnRecv = OnRecv;&#125; OnRecv 到数据以后，开始分析收到的数据，我们将受到数据进行反序列化成为我们日常读写的字符。 123456//将实际函数的实现用委托来和client实现数据的交互public delegate object RpcMethod(List&lt;object&gt; param);//可以在初始化的时候 将RPC的方法通过委托注册进ListRpcMethod的列表ListRpcMethod.add(&quot;Add&quot;, Add)通过委托不会同步等待数据 导致主干的逻辑受到影响 拿到分析后的数据，去执行相应的函数，我们这里用的是C#的委托进行，返回执行结果。 将结果序列化以后，Send 出去。 1234if (m_Client != null) &#123; Socket.Send(m_Client, messgae, messgae.Length); &#125; 服务端单方面结果完毕，大概就是这么个过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2018%2F05%2F11%2FTest%2F</url>
    <content type="text"><![CDATA[hello]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
