<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RPC的初步了解（二）]]></title>
    <url>%2F2018%2F05%2F22%2FRPC%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇已经大致说了Server端，RPC的基本信息，这里主要说Client端相关的。我这里主要以Python为例子。大概了解一下过程，怎么去使用，以及大概的原理。这里主要根据实际使用的一个游戏自动化开源框架说一下这个是怎么使用的。 123456789101112//连接到server端connectionToServer(addr,connect_default_device)--if device_platform() == &quot;Android&quot;: # always forward port for Android # unity games poco sdk listens on Android localhost:5001 current_device().adb.forward(&quot;tcp:%s&quot; % addr[1], &quot;tcp:5001&quot;, False)---- self.conn = TcpClient(addr) self.c = RpcClient(self.conn)-- 自己使用这个接口的时候，需要使用RPClient传出来的接口，例如：1234class UnityPocoJX3MEx(): def __init__(self, agent, poco): self.rpcclient = agent.c self.poco = poco 通过封装的cmd接口，将函数传到服务端，如下所示：12345def callCmd(self, cmd, *param): return self.rpcclient.call(cmd, *param)def cmd(self, cmd, *param): return self.callCmd(cmd, *param) 举个我们最上层使用的例子：Click是我们在Server端，定义的RPC的函数，strUIPath是我们定义的函数参数，cmd_result_click是函数执行以后函数的返回值。1cmd_result_click = poco.pocoEx.cmd(&apos;Click&apos;, strUIPath)]]></content>
  </entry>
  <entry>
    <title><![CDATA[RPC的初步了解（一）]]></title>
    <url>%2F2018%2F05%2F15%2FRPC%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这里应该是主要写写基本的概念和整个流程，以及服务端处理的流程。 RPC:Remote Procedure 远程调用过程使用的环境：在准备搭建自动化收集数据的平台，因为游戏的很多客户端逻辑是C#构造的，所以一些功能性操作都是基于C#的函数，但是想用AutoGo框架来写自动化的测试用例，这时候需要跨服务使用其他语言的接口，这种情况下，接触到了RPC. 基本概念知识：1.RPC 是基于Tcp/Ip底层协议，C/S模式的一种模式。2.目的： 1.实现不同语言之间的通信，例如我这次的使用原因。 2.调用其他端，不是本机的方法。 3.使用简单，可以用简单的网络传输调用，我这里主要会研究一下，Socket的调用。 使用方法RPC 服务端通过一个通信方式 ，【导出】远程接口方法，客户端用 import 【导入】远程接口。 client 调用一些‘本地’方法。 client stub 接收到调用方法以后，将方法和参数等按照约定好的规则编码成可以在传输层传输的消息。 client stub 将编码好的规则发送到服务器 服务端监听到消息以后，开始对接收到的消息进行解码。 根据解码以后的消息规则，找到对应的函数去执行 将执行的结果进行编码，在返回给出了client.盗用一张图来说明大概过程： 这里首先主要理清楚服务端做的操作：整个操作，比较简单的操作其实就是： 服务端开启网络监听端口， 主要监听是否有连接或者数据发过来123456789// 监听 事件Socket.Listen(ip, port, OnAccept)// 自定义事件OnAccept()&#123; //自定义两个事件 so.OnError = OnError; so.OnRecv = OnRecv;&#125; OnRecv 到数据以后，开始分析收到的数据，我们将受到数据进行反序列化成为我们日常读写的字符。 123456//将实际函数的实现用委托来和client实现数据的交互public delegate object RpcMethod(List&lt;object&gt; param);//可以在初始化的时候 将RPC的方法通过委托注册进ListRpcMethod的列表ListRpcMethod.add(&quot;Add&quot;, Add)通过委托不会同步等待数据 导致主干的逻辑受到影响 拿到分析后的数据，去执行相应的函数，我们这里用的是C#的委托进行，返回执行结果。 将结果序列化以后，Send 出去。 1234if (m_Client != null) &#123; Socket.Send(m_Client, messgae, messgae.Length); &#125; 服务端单方面结果完毕，大概就是这么个过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2018%2F05%2F11%2FTest%2F</url>
    <content type="text"><![CDATA[hello]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
